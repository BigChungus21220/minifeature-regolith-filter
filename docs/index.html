<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="description" content="Documentation for the MiniFeature Regolith Filter for MCBE">
  <meta name="keywords" content="MCBE, Minecraft, Regolith">
  <meta name="author" content="BigChungus21220">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MiniFeature Docs</title>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link rel="icon" type="image/x-icon" href="./favicon.ico">
  <link rel="stylesheet" lazyload href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=close,keyboard_arrow_down,keyboard_arrow_right,link,menu"/>
  <style>
    :root {
      --light-text-bg: #f0f0f0;
      --dark-text-bg: #e5e5e5;
      --extra-dark-text-bg: #a5a5a5;

      --link-color: #345fbd;
      --link-pressed-color: #214798;
      --link-visited-color: #aa75d3;

      font-family:'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif
    }

    schema {
      border-bottom: 1px solid var(--dark-text-bg);;
      font-family: monospace;
      padding: 5px;
      width: calc(100vw - 50px - 17px - 15lh - var(--page-offset));
      transition: width 0.3s ease;
      overflow-x: auto;
      white-space: nowrap;
      padding-bottom: 15px;
      scrollbar-gutter: stable;
      display: block;
    }
    
    tree {
      display: block;
      margin-left: 2lh;
    }

    block {
      background-color: var(--dark-text-bg);
      font-family: monospace;
      padding-left: 3px;
      padding-right: 3px;
      border-radius: 3px;
    }

    a {
      color: var(--link-color);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    a:active {
      color: var(--link-pressed-color);
    }

    a:visited {
      color: var(--link-visited-color);
    }

    l2 {
      font-size: 12pt;
    }

    l3 {
      font-size: 10pt;
    }

    button {
      background-color: transparent;
      margin: 5px;
      border-radius: 3px;
      outline: none;
      border: none;
    }

    button:hover {
      background-color: var(--dark-text-bg);
      outline: 1px solid var(--extra-dark-text-bg);
    }

    button:active {
      background-color: var(--extra-dark-text-bg);
    }

    button.icon-button {
      aspect-ratio: 1;
      width: 36px;
      height: 36px;
    }

    h3 {
      --show-section-link: hidden;
    }

    h3:hover {
      --show-section-link: visible;
    }

    h2 {
      --show-section-link: hidden;
    }

    h2:hover {
      --show-section-link: visible;
    }

    ul {
      list-style-type: none;
      padding-left: 15px;
    }

    .material-symbols-outlined {
      align-self: center;
      vertical-align: middle;
      font-variation-settings:
      'FILL' 0,
      'wght' 400,
      'GRAD' 0,
      'opsz' 24
    }

    .snippet {
      background-color: var(--light-text-bg);
      font-family: monospace;
      white-space: pre;
      width: calc(100vw - 50px - 17px - 15lh - var(--page-offset));
      transition: width 0.3s ease;
      overflow-x: auto;
      margin-top: 10px;
      margin-bottom: 10px;
      display: block;
    }

    .github_link {
      margin: 5px;
      border-radius: 3px;
      display: inline-block;
      align-content: center;
      text-align: center;
      width: 36px;
      height: 36px;
    }

    .github_link:hover {
      background-color: var(--dark-text-bg);
      outline: 1px solid var(--extra-dark-text-bg);
    }

    .github_link:active {
      background-color: var(--extra-dark-text-bg);
    }

    .github_logo {
      width: 25px;
      height: 25px;
      align-self: center;
      vertical-align: middle;
    }

    .section_link {
      padding-left: 5px;
      visibility: var(--show-section-link);
    }

    .section_expand_button {
      aspect-ratio: 1;
      margin: 0;
      padding: 0;
    }

    .error {
      color: red;
    }

    .indent {
      margin-left: 15px;
    }

    .snippet_header {
      padding-left: 5px;
      font-style: italic;
      background-color: var(--dark-text-bg);
      border-bottom: var(--extra-dark-text-bg);
    }

    #page {
      position: fixed;
      top: 0;
      display: flex;
      --page-offset: -15lh;
      left: var(--page-offset);
      transition: left 0.3s ease;
    }

    #page.sidebar-open {
      --page-offset: 0lh;
    }

    #sidebar {
      height: 100vh;
      background-color: white;
      display: inline-block;
      width: 15lh;
      overflow-y: auto;
      border-right: 1px solid var(--dark-text-bg);
    }

    #sidebar_close {
      float: right;
    }

    #header {
      align-content: center;
      display: flex;
      position: sticky;
      top: 0;
      background-color: white;
      height: fit-content;
      border-bottom: 1px solid var(--dark-text-bg);
      width: 100%;
    }

    #scroll_content {
      display: inline-block;
      width: calc(100vw - 17px - 15lh - var(--page-offset));
      transition: width 0.3s ease;
      margin-left: 15px;
      height: 100vh;
      overflow-y: auto;
      scroll-padding-top: 80px;
    }
  </style>
</head>
<body>
  <script>
    function toggleExpand(button, target_id){
      const target = document.getElementById(target_id);
      if (target.style.display === "none"){
        target.style.display = "block";
        button.innerHTML = `<span class="material-symbols-outlined">keyboard_arrow_down</span>`;
        button.name = "minimize section";
      } else {
        target.style.display = "none";
        button.innerHTML = `<span class="material-symbols-outlined">keyboard_arrow_right</span>`;
        button.name = "expand section";
      }
    }
  </script>

  <div id="page">
    <div id=sidebar>
      <button name="close menu" class="icon-button" id="sidebar_close">
        <span class="material-symbols-outlined">close</span>
      </button>
      <div id="sidebar_content">
  
      </div> 
    </div>
  
    <div id="scroll_content">
      <div id="header">
        <button name="menu" class="icon-button" id="sidebar_open">
          <span class="material-symbols-outlined">menu</span>
        </button>
        <a class="github_link" href="https://github.com/BigChungus21220/minifeature-regolith-filter" target="_blank">
          <img id="github_logo" alt="Github Logo" width="25" height="25" src="./github-mark.svg"></img>
        </a>
      </div>
      <div id="main_content">
      </div>
    </div>
  </div>

<script type="module">
  const menu_open = document.getElementById("sidebar_open");
  const menu_close = document.getElementById("sidebar_close");
  const page = document.getElementById("page");
  let focused = null;

  menu_open.onclick = () => {
    page.classList.add("sidebar-open");
  };

  menu_close.onclick = () => {
    page.classList.remove("sidebar-open");
  };

  const schema_prefix = "https://raw.githubusercontent.com/BigChungus21220/minifeature-regolith-filter/refs/heads/master/minifeature/schemas/";
  const schema_entrypoint = "feature_file.schema.json";
  const main_content = document.getElementById("main_content");
  const sidebar_content = document.getElementById("sidebar_content");
  const base_url = window.location.pathname;

  let sections = {};

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  function makeSectionLink(id, level){
    if (level === 2){
      sections[id] = [];
    } else {
      sections[Object.keys(sections)[Object.keys(sections).length - 1]].push(id);
    }
    return `<a class="section_link" href="${base_url}#${id}"><span class="material-symbols-outlined">link</span></a>`
  }

  let ref_queue = [];
  let ref_registry = [];

  function add_ref(ref){
    if (!ref_registry.includes(ref)){
      ref_queue.push(ref);
      ref_registry.push(ref);
    }
  }

  async function document_ref(ref) {
    let html = "";
    const ref_name = ref.split(".")[0];
    sections["Schemas"].push(ref_name);
    html += `<h3 id=${ref_name}>${ref_name}${makeSectionLink(ref_name), 3}</h3>`
    try {
      const data = await fetch(schema_prefix + ref);
      const json = await data.json();
      html += `<schema>`;
      html += display_schema(json);
      html += `</schema>`;
    } catch {
      html += `<p class="error">Failed to load resource: ${schema_prefix + ref}</p`;
    }
    return html;
  }

  function display_schema(schema) {
    let html = "";
    switch (schema.type) {
      case "object":
        html += `${"default" in schema ? `${JSON.stringify(schema.default)} |` : ``} &lt;object&gt; ${(schema.description ? "// " + schema.description : "")}<tree>`;
        for (const key in schema.properties) {
          const is_opt = !(schema.required && schema.required.includes(key));
          html += `<block>${key}</block>: ${is_opt ? `opt` : ""} `;
          html += display_schema(schema.properties[key]);
        }
        for (const key in schema.patternProperties) {
          const is_opt = !(schema.required && schema.required.includes(key));
          html += `<block>${key}</block>+: ${is_opt ? "opt" : ""} `;
          html += display_schema(schema.patternProperties[key]);
        }
        html += `</tree>`;
        break;
      case "string":
        html += `${"default" in schema ? `"${schema.default}" |` : ``} &lt;string${schema.contentMediaType === "text/molang" ? "/molang" : ""}&gt; ${(schema.pattern ? schema.pattern : "")} ${("description" in schema ? "// " + schema.description : "")}`;
        if ("enum" in schema){
          html += `<tree>`;
          for (const option of schema.enum){
            html += `"${option}"<br/>`
          }
          html += `</tree>`;
        } else {
          html += `<br/>`;
        }
        break;
      case "number":
        let bounds = "";
        if ("minimum" in schema || "maximum" in schema){
          if ("minimum" in schema){
            bounds += `${schema.minimum}â€”`;
          } else {
            bounds += `-âˆžâ€”`;
          }
          if ("maximum" in schema){
            bounds += `${schema.maximum}`;
          } else {
            bounds += `âˆž`;
          }
          bounds = `[${bounds}]`;
        }
        html += `${"default" in schema ? `${schema.default} |` : ``} &lt;number&gt;${bounds} ${("description" in schema ? "// " + schema.description : "")}<br/>`;
        break;
      case "integer":
        let int_bounds = "";
        if ("minimum" in schema || "maximum" in schema){
          if ("minimum" in schema){
            int_bounds += `${schema.minimum}â€”`;
          } else {
            int_bounds += `-âˆžâ€”`;
          }
          if ("maximum" in schema){
            int_bounds += `${schema.maximum}`;
          } else {
            int_bounds += `âˆž`;
          }
          int_bounds = `[${int_bounds}]`;
        }
        html += `${"default" in schema ? `${schema.default} |` : ``} &lt;integer&gt;${int_bounds} ${("description" in schema ? "// " + schema.description : "")}<br/>`;
        break;
      case "boolean":
        html += `${"default" in schema ? `${schema.default} |` : ``} &lt;boolean&gt; ${("description" in schema ? "// " + schema.description : "")}<br/>`;
        break;
      case "array":
        let count = "";
        if ("minItems" in schema){
          count += schema.minItems;
        } else {
          schema.minItems = 0;
          count += "0";
        }
        if ("maxItems" in schema){
          if (!(schema.maxItems === schema.minItems)){
            count += `...${schema.maxItems}`;
          }
        } else {
          count += `...`;
        }

        html += `${"default" in schema ? `[${schema.default}] |` : ``} &lt;array&gt;[${count}] ${(schema.description ? "// " + schema.description : "")}<tree>`;
        if ("items" in schema){
          if (Array.isArray(schema.items)){
            for (let i = 0; i < schema.items.length; i++){
              html += `(${i}): <tree>`;
                html += display_schema(schema.items[i]);
              html += `</tree>`;
            }
          } else {
            html += display_schema(schema.items);
          }
        }
        html += `</tree>`;
        break;
      default:
        if (schema.anyOf){
          html += `${"default" in schema ? `${schema.default} |` : ``} ${(schema.description ? "// " + schema.description : "")} <tree>`;
          for (const option of schema.anyOf){
            html += display_schema(option);
          }
          html += `</tree>`
        } else if (schema["$ref"]){
          const ref_name = schema["$ref"].split(".")[0];
          html += `<a href="#${ref_name}">&lt;${ref_name}&gt;</a> ${(schema.description ? "// " + schema.description : "")}<br/>`;
          add_ref(schema["$ref"]);
        } else if ("const" in schema){
          let value;
          if (typeof schema.const === "string"){
            value = `"${schema.const}"`;
          } else {
            value = `${schema.const}`;
          }
          html += `${value} ${("description" in schema ? "// " + schema.description : "")}<br/>`;
        }
        //if has any_of or has ref, use that
        //todo: ensure any_of and other props are mutually exclusive
        break;
    }
    return html;
  };

  function makeSnippet(text, filename){
    let html = `<div class="snippet"><div class="snippet_header">${filename}</div>`;
    const lines = text.split("\n");
    for (const line of lines){
      html += line + "<br/>";
    }
    return html + `</div>`;
  }



  main_content.innerHTML = `
    <h1>MiniFeature Documentation</h1>
    <h2 id="Overview">Overview${makeSectionLink("Overview", 2)}</h2>
    <div class="indent">
      <p>MiniFeature is a preprocessor for <a href="https://wiki.bedrock.dev/world-generation/world-generation-intro">MCBE world gen features</a>.</p>
      <p>The MiniFeature format allows for inline feature definition, templating, variables, namespacing, and defining multiple features in one file.</p>
      
      <h3 id="Prerequisites">Prerequisites${makeSectionLink("Prerequisites", 3)}</h3>
      <p>This documentation assumes you are familiar with <a href="https://wiki.bedrock.dev/guide/introduction">Minecraft Bedrock Edition addons</a>, <a href="https://wiki.bedrock.dev/world-generation/feature-types">vanilla world generation feature types</a>, and <a href="https://regolith-docs.readthedocs.io/en/latest/introduction/getting-started/">Regolith usage</a>.</p>

      <h3 id="Installation">Installation${makeSectionLink("Installation", 3)}</h3>
      To install MiniFeature to a Regolith project, run <block>regolith install minifeature --profile=default</block> or <block>regolith install github.com/BigChungus21220/minifeature-regolith-filter/minifeature --profile=default</block>.

      <h3 id="Editor-Setup">Editor Setup${makeSectionLink("Editor-Setup", 3)}</h3>
      <p>If using VSCode, you may enable schema validation by adding the following to your <block>settings.json</block>:</p>
${makeSnippet(
`"json.schemas": [
  {
    "fileMatch": [
      "**/*.minifeature.json"
    ],
    "url": "https://raw.githubusercontent.com/BigChungus21220/minifeature-regolith-filter/refs/heads/master/minifeature/schemas/feature_file.schema.json"
  }
],
"yaml.schemas": {
  "https://raw.githubusercontent.com/BigChungus21220/minifeature-regolith-filter/refs/heads/master/minifeature/schemas/feature_file.schema.json": "**/*.minifeature.yaml"
}`, ".vscode/settings.json"
)}
    </div>

    <h2 id="Usage">Usage${makeSectionLink("Usage", 2)}</h2>
    <div class="indent">
      <p>MiniFeatures should be placed in <block>BP/minifeatures/</block> and should have the extension <block>.yaml</block>, <block>.json</block>, or <block>.jsonc</block>.&emsp;<block>.yaml</block> is recommended as it supports multiline strings, allowing for clean inline molang.</p>
      MiniFeature files start with a namespace for all features within the file. Multiple files may share the same namespace.
      <br/>
      ${makeSnippet(
`{
  namespace: "myfeature"
  ...
}`, "myfeature.minifeature.yaml"
      )}
      <br/>
      Features start with a name which must be lowercase and start with a letter or underscore. Following characters may include numbers.<br/>
      Features contain a type which specifies the type of feature defined.
      ${makeSnippet(
`{
  namespace: "myfeature",

  my_rule0: {
    type: "rule",
    ...
  }
}`, "myfeature.minifeature.yaml"
      )}
      <br/>
      Features may place other features, either through an inline definition, local reference, namespaced reference, or vanilla feature reference.
      ${makeSnippet(
`{
  namespace: "myfeature",

  my_rule0: {
    type: "rule",
    places: { # inline definition
      type: "aggregate",
      places: [
        "my_scatter", # local reference
        "myotherfeature.myblock", # namespaced reference
        "minecraft:oak_tree_feature" # vanilla reference
      ]
    },
    ...
  }

  my_scatter: {
    ...
  }
}`, "myfeature.minifeature.yaml"
      )}
      <br/>
      <h3 id="Variables and Templates">Variables and Templates${makeSectionLink("Variables and Templates", 3)}</h3>
      Minifeatures may contain variables as properties in the form <block>$var_name$</block>. Variables may contain any value, object, or array.<br/>
      Variables may also be placed within a molang string, allowing for templated molang.<br/>
      Minifeatures may also contain templates, which do not directly create features, but instead convert to inline features, which may differ based on the variables set.
      ${makeSnippet(
`{
  namespace: "myfeature",

  my_rule0: {
    type: "rule",
    $my_var$: "minecraft:oak_tree_feature",
    places: {
      type: "aggregate",
      places: [
        "my_scatter",
        "$my_var$" # Replaced with "minecraft:oak_tree_feature".
        {
          inherits: "<my_templated_scatter>"
        }
      ]
    },
    ...
  }

  my_scatter: {
    places: $my_var$ # Fails to replace since $my_var$ is out of scope.
    ...
  }

  &lt;my_templated_scatter&gt: {
    places: $my_var$ # Replaced with "minecraft:oak_tree_feature" as it is templated.
    ...
  }
}`, "myfeature.minifeature.yaml"
      )}
      <br/>
    </div>
    <h2 id="Schemas">Schemas${makeSectionLink("Schemas", 2)}</h2>
    <div id="schema_display" class="indent">
  `;

  const schema_display = document.getElementById("schema_display");

  add_ref(schema_entrypoint);

  while (ref_queue.length !== 0){
    const ref = ref_queue.shift();
    //await sleep(25);
    schema_display.innerHTML += await document_ref(ref);
  }



  let sidebar_html = "<ul>";

  for (const key in sections) {
    sidebar_html += `<li><l2><a href="${base_url}#${key}">${key}</a></l2>
      <button name="expand section" class="section_expand_button" onclick="toggleExpand( this, '${key}_subsections');"><span class="material-symbols-outlined">keyboard_arrow_down</span></button><ul id="${key}_subsections">`;
    for (const subsection of sections[key]){
      sidebar_html += `<li><l3><a href="${base_url}#${subsection}">${subsection}</a></l3></li>`
    }
    sidebar_html += `</ul></li>`;
  }

  sidebar_html += "</ul>";

  sidebar_content.innerHTML = sidebar_html;

</script>

</body>
</html>
